##############
Using Services
##############

With both a :ref:`service specification written <write>` and
:ref:`implemented <implement>` it is now time to start using the service
in client applications. To get started, a client application will need
a copy of the service specification that has been distributed. If it
has been :ref:`bundled into a Python package and uploaded <distribute>`
to a package index then it should be as simple installing it with Pip.

.. code-block:: shell

    $ pip install calculator==0.1.0

Or perhaps it's distributed by other means, such as copy-pasting it
into some documentation ...

.. code-block:: yaml

    service:
      name: calculator
      version: 0.1.0
      description: An example service for basic arithmetic.

    functions:
      - name: add
        description: Add two numbers together.
        arguments:
          - name: a
            description: Left addition operand.
            schema:
              type: integer
          - name: b
            description: Right addition operand.
            schema:
              type: integer
        returns:
          description: Sum of the two numbers.
          schema:
            type: integer


**************************
Example: Calling Functions
**************************

As when implementing the simple calculator service, to *use* it, it must
be first converted to Python using :program:`skyhook-generate`. Which
will generate an importable Python package in the current directory.

.. code-block:: shell

    $ skyhook-generate calculator  # if installed from a package
    $ skyhook-generate --file calculator.yaml

Note how this process is identical as used when implementing the
service. In fact, assuming the same version of Skyhook is used, the
exact same generated Python code is used for both *sides* of the
service. Although do bear in that there's no requirement for service
implementers and clients to use the same version of Skyhook!

Having generated the code for the service, it can be imported like any
other Python module.

.. code-block:: python

    # application.py
    import calculator

Intuitively, one might attempt to call one of the service functions.

.. code-block:: python

    import calculator

    calculator.add(5, 5)

Only to be unceremoniously met with a :exc:`NotImplementedError`.

.. code-block:: pytb

    Traceback (most recent call last):
      File "application.py", line 3, in <module>
        calculator.add(5, 5)
      File "...\skyhook\examples\calculator\calculator\functions.py", line 8, in add
        return __import__("skyhook").Hook.current().call("add", a, b)
      File "...\skyhook\skyhook\hook.py", line 119, in current
        raise NotImplementedError("no hook bound")
    NotImplementedError: no hook bound

Before calling into a service, the Skyhook generated library must be
first told where the implementation lives. Or in other words, it must
be fed the ARNs of the Lambda functions that provide the service. This
is done by constructing a :class:`skyhook.Hook` and configuring it with
ARNs before activating it.

.. code-block:: python

    import skyhook
    import calculator

    hook = skyhook.Hook(calculator)
    hook.define("add", arn="arn:aws:lambda:eu-west-2:123456789012:function:add")
    with hook.bind():
        assert calculator.add(5, 5) == 10

Now when using :func:`calculator.add`, Skyhook will dispatch the the
call to the Lambda function that was configured for it using the
active hook. The given arguments are serialised into the input payload
that will be submitted to the Lambda. The arguments are validated
before the Lambda is invoked, returning a :class:`skyhook.ContractError`
if they are not valid. The return value of the Lambda function is
similarly deserialised and validated before being returned to the
calling code.


.. _messages-send:
.. _messages-recv:

******************************
Sending and Receiving Messages
******************************

If the service definition includes any messages, they will also be
included in the library generated by :program:`skyhook-generate`. Unlike
functions, the distinction between the "implementer" and "user" is less
obvious so the terms *sender* and *receiver* are used instead.

For messages, an example monitoring service will be used ...

.. code-block:: yaml

  service:
    name: monitoring
    version: 0.1.0
    description: An example service for monitoring systems.

  messages:
    - name: alerts
      description: Notification about state of the system.
      schema: {$ref: "#/types/alert"}

  types:
    - name: alert
      description: Single emittable alert.
      schema:
        type: object
        properties:
          message: {type: string}
          level:
            enum:
              - debug
              - info
              - error

Generating the service's Python package is the same with any other
service.

.. code-block:: shell

  $ skyhook-generate monitoring  # if installed from a package
  $ skyhook-generate --file monitoring.yaml

To publish a message, as with calling a function, a
:class:`skyhook.Hook` must be constructed and activated. The hook must
also be configured with destination of the messages -- either
an SNS topic or an SQS queue -- as identified by an ARN. Actually
sending the message is then the trivial matter of calling ``send``
method with the message payload.

.. code-block:: python

  # application.py
  import monitoring

  hook = skyhook.Hook()
  hook.define("alerts", arn="arn:aws:sqs:us-east-2:123456789012:alerts")
  with hook.bind():
      monitoring.alerts.send({
        "message": "Starting application",
        "level": "info",
      })

Note how the named message bus is made available in the imported
package under a name derived from the service definition --
``monitoring.alerts``. This is a :class:`skyhook.Messenger` which,
when used to send messages, validates and then suitably encodes the
message, before forwarding it to the previously configured topic or
queue, using the active hook.

If the given message does not match the ``schema`` from the service
definition, a :exc:`skyhook.ContractError` will be raised. However,
note that :meth:`.Messenger.send` is also fully type annotated, making
it likely that any egregiously invalid messages will be caught by a
type checker before runtime.


Receiving Messages using Lambda
###############################

For receiving messages, Skyhook provides utilities similar to those
used for :ref:`implementing functions using AWS Lambda
<implement-lambda>`. By using Lambda, a number of the complexities
in communicating with the underlying message transport is handled by
the the Lambda integration. This is most notable for SNS-bound messages
as the subscription-confirmation process is handled transparently.

To receive messages ...

.. code-block:: python

  import monitoring

  @monitoring.alerts.lambda_
  def on_alert(alert: monitoring.Alert):
      store(alert)
      if alert["level"] == "error":
        escalate(alert)

Attached to the earlier described :class:`.Messenger` there is a
:class:`skyhook.message.MessengerLambda`, which can used to decorate
a function and turn it into into a Lambda entry-point that processes
incoming messages.

Like when sending messages, the inbound message is validated against
the service definition's schema before being passed onwards to the
implementation function. Validation failures result in a
:exc:`skyhook.ContractError` being raised. The decorated function
also benefits from the same type annotations as on the sending side.

Note that, when receiving messages via a Lambda, there is no need
to configure a :class:`.Hook`. Instead, the Lambda function where the
code will be run must be configured with an integration pointed at the
known SNS topic or queue. See :meth:`skyhook.message.MessengerLambda.wrap`
for details on how message batching is handled.


********************************
Notes on the Client-Server Model
********************************

In this documentation, many of the examples discuss scenarios where a
service neatly fits a conventional client-service, request-response
design. With the example calculator service above, although somewhat
contrived, it is easy to imagine an implementation where there is a
calculator "*server*" that accepts requests from "*clients*" to perform
arithmetic operations.

Skyhook purposefully avoids this language; preferring the terms service
*implementers* and service *users*. This is because Skyhook makes no
assumption that a service definition is wholly implemented on a single
"side". Instead, its accepted that some functions from the service
definition could be implemented by the so-called server *and* the
client. Or in other words, its expected that a service definition may
only be partially implemented by any single implementation.

.. note::

  This similarly applies to messages although the distinction between
  a message implementer and user is less clear. Instead, *sender* and
  *receiver* are best used.


Callbacks
#########

An example of where this is useful is for services where there needs
to exist a notion of callbacks. Functions that can be called
asynchronously by a service implementer in response to an earlier call
or message from a user.

An example of this could be a search indexing service. Where an
application sends a message to the indexing service to inform it of a
document needing re-indexing, but the document itself is only loaded
by the indexing service calling back into the application.

.. code:: text

  Indexer <-- Index Request -- Application
      |       Containing ID         ^
      V                             |
  Build batch                       |
      |                             |
      V                             |
  Load documents <---- load(id) ----`
      |
      V
    Index

This design affords the indexing service the opportunity to ultimately
control when indexing is performed -- e.g. to manage load or wait for
efficient batches to be built -- irrespective of the application's
demands. Additionally, it also avoids documents sitting around in
queues while a large backlog is worked through, reducing the probability
of stale records being indexed. The latter may also be desirable for
cases where the documents to be indexed contain sensitive information
as it removes another location (the message queue) where they could be
vulnerable to interception.

Finally, it also allows for the indexer to be the initiator of the
request in the first place. For example, if rebuilding an index from
scratch after schema change or data loss.

With Skyhook, the index request messages and the document loading
function can be defined as being part of a single service. Where it is
the indexer's responsibility to implement the message handler and the
application(s)' responsibility to implement the document loading
function.

However, it is also equally reasonable to use two different service
definitions to the same effect. Skyhook is accepting of both approaches.


Stateful Services
#################

More often than not, services are in some way stateful. Consider any
service that allows a user to create a record to be stored in a database
with some ID and then later retrieve that same record using the ID.

In such cases, it's imperative that the service user is talking to the
same implementation for both steps. If there was a different
implementation for the *create record* function as there is for the
*retrieve record* that did not share a common database, the latter
request would naturally fail.

Although almost certainly obvious, this fact should not be overlooked
when designing a service that makes use of multiple concurrent
implementations.


*****************
Service Discovery
*****************

By using :meth:`Hook.define`, Skyhook is being told the location of
the service implementation through ARNs. Skyhook itself does not come
with any mechanism for discovering what the correct ARNs should be.
As such, how the application comes to know these values is entirely
at the discretion of the reader. Consequent to this unopinionated
stance, Skyhook should happily integrate with any runtime configuration
management or conventions that may already exist in the application.


Permissions
###########

In addition to knowing the ARNs of the implementation, Skyhook will need
permission to access the given resources. As these resources are just
AWS services, access control takes the usual path through AWS Identity
and Access Management (IAM).

Skyhook will use whatever credentials are available to its underlying
:class:`boto.Session` when making requests to AWS services. What
permissions these credentials must convey depend on the AWS services
used to implement the Skyhook service.

.. tip::

  For message receivers implemented as Lambda functions, by default
  the credentials used will come from the Lambda's execution role.

+----------+---------------+--------------------------------+
| Type     | Service       | IAM Permissions                |
+==========+===============+================================+
| Function | Lambda        | | ``lambda:InvokeFunction``    |
+----------+---------------+--------------------------------+
| Function | Step Function | | ``states:StartExecution``    |
|          |               | | ``states:DescribeExecution`` |
+----------+---------------+--------------------------------+
| Message  | SNS           | | ``sns:Publish`` :sup:`1`     |
|          |               | | ``sns:Subscribe`` :sup:`2`   |
+----------+---------------+--------------------------------+

1. For message senders only.
2. For message receivers only.

Note that for most of these services, there are also corresponding
resource-level policies. These policies may need to be additionally
configured to allow the identity assumed by Skyhook to access the
resource.


**************************
Implementation Binding API
**************************

.. autoclass:: skyhook.Hook
    :members:
    :undoc-members:


***************
Message Bus API
***************

.. autoclass:: skyhook.Messenger
   :members:
   :undoc-members:


.. autoclass:: skyhook.message.MessengerLambda
   :members:
   :undoc-members:
