.. _code:
.. _sdk:

########################
Code Generation and SDKs
########################

At the core of Skyhook is the code generator. It is this generator that
reads service definitions and turns them into type-safe and runtime
validated Python code. Code generation can be added to existing build
processes to generate lightweight software development kits on-the-fly,
avoiding the need to maintain separate SDKs alongside the service
implementations.

On this page it is assumed that the reader is already in posession of
a :ref:`service specification <write>`.


**********************
Notes on Compatibility
**********************

The SDKs generated by Skyhook are extremely lightweight. They contain
*just enough* code that they seamlessly integrate with other development
tools such as IDEs or type checkers. All in all, they're not much more
than a stub-only package (see :pep:`561`) that ships only type
information. With all of the heavy lifting being done by calls into
:mod:`skyhook` itself.

Consequently, generated code is sensitive to the Skyhook version used.
In short, the **version of Skyhook used to generate the code must match
the version available at runtime**. This includes minor and patch
releases.

On initial import, the SDK will attempt to verify that the right
version is being used. Raising an :exc:`ImportError` otherwise. However,
because of this, Skyhooks users are strongly discouraged to always
generate SDKs at build time and resist the urge to check them into
version control.

Code generation is generally very fast and entirely deterministic
for a given Skyhook version and service definition.


.. _code-cli:
.. program:: skyhook-generate

*************************************
Using the Command Line Code Generator
*************************************

The easiest way to generate a service SDK is using the
:program:`skyhook-generate` command line tool that comes with Skyhook.
When pointed at a service definition file or :ref:`service definition
package <distribute>` it will create an SDK in the current working
directory.

There are a number of :ref:`options that can be used to tweak the
resultant output <code-config>`. See ``skyhook-generate --help`` for
a comprehensive list of switches.

.. code-block:: shell

    $ skyhook-generate service  # if installed from a package
    $ skyhook-generate --file service.yaml

.. tip::

    Make sure that the generated package is :ref:`included in any built
    distributions <code-include>`.



.. _code-pep517:

********************************
Using the PEP 517 Code Generator
********************************

.. warning::

    Highly experimental.

As an alternative to the command line code generator, a custom
:pep:`517` build backend is provided. This build backend wraps around
any other PEP 517-compliant build tool, such as Setuptools, and
injects the generated code directly into the built wheel or source
distribution.

With this approach, only the native Python build ecosystem is used;
without the need for supporting scripts, Makefiles or similar. However,
this is at the expense of weaker integration with the development
workflow.

To use the PEP 517 code generator, the target code base must use a
:file:`pyproject.toml`.

.. code-block:: toml

    [build-system]
    requires = ["skyhook", "setuptools"]
    build-backend = "skyhook.inject"

    [tool.skyhook.inject]
    build-backend = "setuptools.build_meta"

:ref:`Options <code-config>` can be added to the
``tool.skyhook.injector`` section.

.. note::

    Although not recommended, if there's a desire to distribute SDKs,
    rather than service definitions, the PEP 517 code generator may
    reduce some of the boilerplate needed to create such distributables.

.. _code-config:

******************
Options and Tweaks
******************

.. option:: package-name <name>

    Name of the generated Python package. This is the name that all
    parts of the SDK will be imported from. By default, the package
    name is derived from the service's name.

.. option:: case-hints
.. option:: no-case-hints

    Controls whether case hints are respected when generating Python
    names for :ref:`named elements <names>` in the service definition.
    Where a ``name`` contains an abbreviation, the initials should be
    capitalised. By default, the code generator will follow this
    casing where possible.

    For example, when enabled (the default), a :ref:`type <types>`
    called ``HTTP-header`` would be rewritten as ``HTTPHeader``. If
    disabled, the case hint is ignored and the generated name falls
    back to plain PascalCase -- e.g. ``HttpHeader``.

.. option:: short-names
.. option:: no-short-names

    Controls whether aliases for functions, message buses and types are
    re-exported at the top-level of the generated package. For example,
    making ``foo.types.Bar`` additionally available as ``foo.Bar``.

    By default, short names are enabled. As names are only unique for
    a given type, it is possible that a function name collides with
    the name of a message bus. In such a case, the top-level alias may
    be misleading at a glance. Also, there may exist conventions in the
    target code base which insists on the use of fully qualified names.
    For these reasons, short names can be disabled.

.. _code-pretty:
.. option:: prettify (disabled|preferred|enabled)

    Determines whether generated code will be passed through an
    automated code formatter before being written to file. If
    ``preferred`` (the default) then formatting will be applied only
    if the ``[pretty]`` extra was installed. Conversely, ``enabled``
    will cause code generation to fail entirely if the extra is not
    available.


********************************
Development Workflow Integration
********************************

When using generated code as part of a larger code base it's important
to ensure that it plays well with the associated development workflows.
For Skyhook SDKs, integration with type checkers and IDEs should work
out-of-the-box. With symbols, type annotations and documentation being
automatically detected from the otherwise ordinary Python package.

A few things to bear in mind however ...

- Consider excluding the SDK from any code coverage reports that are
  generated as part of the testing process. Even if only a single
  service function is used by the application, Skyhook will always
  generate a full SDK, leading to unreached code. Also note that
  Skyhook itself is independently well tested and there may be little
  value in including it in test suites -- especially unit tests.

- Consider excluding the SDK from any linting or other code quality
  assurance processes. If :option:`prettify` is enabled, the generated
  code should satisfy most linting tools. However, the formatter used
  cannot be expected to be aware of any style convention quirks that
  exist in the target code base. More simply, anything flagged within
  the SDK will most likely just to add noise to the reports.


.. _code-include:

Including Packages in Distributions
###################################

One item that cannot be overlooked is ensuring that the generated
package is included as part of the enclosing Python project. Otherwise,
when the project is built, e.g. into a wheel for distribution or
deployment, the SDK will be missing, inevitably leading to
:exc:`ImportError`\ s.

If using the :ref:`command line code generator <code-cli>`, make sure
that the generated package exists in the correct source directory. For
example, projects that use a :file:`src/` directory will likely want
the SDK placed in that same directory. For those with top-level
packages, the SDK should similarly exist at the top-level.

Additionally ensure that the generated package is listed as one of
the project's own packages. If using package discovery, such as
``find:`` in a :file:`setup.cfg` file or ``find_packages()`` in
:file:`setup.py`, then the SDK will be included automatically; so
long as it exists on the correct source path (see above). If packages
are explicitly enumerated for the project, the SDK's package will need
to be included in that list.

.. warning::

    If :ref:`distributing service definitions as Python packages
    <distribute>` it is not sufficient to merely list the definition
    package in the ``install_requires`` of the project. These packages
    *only* contain the service definition. SDKs must be generated
    separately.

For atypical packaging scenarios: ultimately the generated package
must exist on the Python import search path when the application is
run.


.. _code-struct:

*****************
Package Structure
*****************

SDKs generated by Skyhook are very lightweight; made up of a single,
shallow Python package with only a few submodules. It is rare that the
contents of the generated package need to be inspected directly, but
users of the SDK should understand the general layout, as its from
this package that functions, messages and types will be imported.

In the examples below, the package name of the service SDK will be
unimaginatively taken to be ``service``.


Package: ``service``
####################

Top-level of the SDK. If :option:`short-names` was enabled this will
contain aliases for otherwise deeper nested functions, messages and
types. Note that, should any of these elements have overlapping names,
the aforementioned order indicates the ascending precedence.


Module: ``service.functions``
#############################

Module containing the service functions. These are regular Python
functions which have an additional :class:`skyhook.Lambda` attached
to them under :attr:`lambda_`. Each function takes the ``snake_case``
form of the name from the service definition; modified where necessary
to avoid illegal names or clobbering builtins.


Module: ``service.messages``
############################

Module containing the service message buses. These are
:class:`skyhook.Messenger`\ s assigned to a name that matches the
``snake_case`` form of the name from the service definition. Again,
modified to avoid illegal names or clobbering builtins.


Module: ``service.types``
#########################

Module containing the service type definitions. This module does
does not contain any "*executable*" code. Just type annotations.
Each type from the service definition is assigned to the ``PascalCase``
form of the name from the service definition. Note that this module
also contains ``*Message`` types for each message in the service
definition. If the message ``schema`` is a reference to a first-class
service type, then this will be a simple alias of another member of
the module.


Inline Documentation
####################

Each package, module, function, etc. in the SDK will have docstrings
applied where possible. These docstrings include the ``description``\ s
taken from the service definition and Skyhook-specific comments. As
such, the SDK contains inline documentation that is usable by the
builtin :func:`help` function and all competent IDEs.

Because of this, it is possible to build standalone documentation for
the SDK by, for example, using the Sphinx autodoc extension. An :ref:`\
example of automatically generated SDK documentation <code-autodoc>`
is included in this wider document.

..
    Might need elaboration on inter-Sphinx so that references to
    Skyhook things are not broken.


**********
Exceptions
**********

Skyhook reserves the use of exceptions for signaling low-level errors
from within Skyhook itself. Service-level errors should be :ref:`\
explicitly modelled as part of the service definition <errors>`. As
such, generated service SDKs do not include exception types. However,
all functions and message buses from the SDK may raise a number of
exceptions.


.. autoclass:: skyhook.ContractError
.. autoclass:: skyhook.TransportError
.. autoclass:: skyhook.AccessError
    :show-inheritance:
