"""Bind service users to an implementation.

On their own, packages generated by :mod:`skyhook.generate` do nothing.
They contain type definitions and stub functions only. This is because
knowledge about "where" or "who" the implementation of a service is
generally not known when the packages are generated -- at build time.

During runtime, the application using the package needs to provide
this information. It does this by creating a :class:`Hook` and
configuring it to point at a specific set of Lambda or Step Functions.

Before using any of the functions from the service, the hook must be
bound by calling :meth:`Hook.bind`. While the hook is bound, all
function calls will be passed through to the underlying Lambda or Step
Function.

For most applications, binding a hook need only be done once during
initialisation. For example:

.. code-block:: python

    import skyhook
    import noughts_and_crosses

    def main():
        hook = skyhook.Hook()
        hook.define("play", arn="arn:aws:lambda:eu-west-2:1234567890:function:noughts-crosses-random")
        hook.bind()
        noughts_and_crosses.play("X", (
            None, None, None,
            None, None, None,
            None, None, None,
        ))

How the application comes to being aware of the hook definition is at
its discretion. Often this will be configuration injected into the
application at deployment time but other service discovery mechanisms
can be used.
"""

import contextlib
import json

import arnparse
import boto3
import jsonschema


class Hook:
    """Configure a known service implementation.

    Hooks are defined for package generated by :mod:`skyhook.generate`.
    Hooks are configured with pointers to an implementation of the
    service by calls made to :meth:`define` -- e.g. the ARNs to Lambda
    functions.

    By default, hook are inactive. To activate a hook it must be
    bound by calling :meth:`bind`. Only one hook can be activate at
    a time for any given service.

    When a service function from the generated package is called, it
    will use the currently active hook to dispatch a call to the
    configured implementation. All arguments will be validated against
    the service specification before being dispatched. Values returned
    by the implementation are subjected to similar validation before
    being exposed to the calling code.

    Return value validation can be disabled where the implementation
    is trusted to implement the service specification correctly. This
    offer a small optimisation in exchange for slightly weaker level
    of protection for the calling code.
    """

    # TODO: thread safety in general
    # TODO: key against module
    _stack = []

    def __init__(self, module):
        self._functions = {}
        self._channels = {}
        self._module = module
        self._service = __import__(
            f"{module.__name__}._spec", fromlist=[...]).service

    def define(self, name, *, arn):
        """Define implementation of service function by name."""
        arn_parsed = arnparse.arnparse(arn)
        if arn_parsed.service in ["lambda"]:
            self._functions[name] = arn
        elif arn_parsed.service in ["sns", "sqs"]:
            self._channels[name] = arn
        else:
            raise ValueError(f"cannot use '{arn_parsed.service}' in hook")

    def bind(self):
        """Make the hook ready for use.

        Once the hook is bound, attempts to call service functions
        will be routed via the hook, calling out to the configured
        AWS services as necessary.

        When used as a context manager multiple hooks can be bound
        in a nested fashion. One per ``with`` statement. It is possible
        to bind a hook without the use of the context manager but
        this should only be done when the binding is made early in
        the application's life cycle and remains in place until
        termination.

        :returns: Context manager which will unbind the hook on exit.
        """
        self._stack.append(self)

        @contextlib.contextmanager
        def _unbind():
            try:
                yield
            finally:
                self._stack.pop()

        return _unbind()

    @classmethod
    def current(cls):
        """Get currently active hook."""
        if not cls._stack:
            raise NotImplementedError("no hook bound")
        return cls._stack[-1]

    def call(self, name, *args, **kwargs):
        if name not in self._functions:
            raise NotImplementedError(f"no implementation for '{name}'")
        arn = self._functions[name]
        arn_parsed = arnparse.arnparse(arn)
        if arn_parsed.service != "lambda":
            raise NotImplementedError(
                f"no {arn_parsed.service} implementation for '{name}'")
        function = self._service.function(name)
        return self._call_lambda(function, arn, *args, **kwargs)

    def _call_lambda(self, function, arn, *args, **kwargs):
        arn_parsed = arnparse.arnparse(arn)
        session = boto3.Session(region_name=arn_parsed.region)
        client = session.client("lambda")
        payload = self._build_lambda_payload(function, *args, **kwargs)
        invocation = client.invoke(
            FunctionName=arn,
            Payload=json.dumps(payload).encode(),
        )
        return_ = json.load(invocation["Payload"])
        trusted = False  # TODO: defined by application
        if function.return_:
            if not trusted:
                try:
                    jsonschema.validate(return_, function.return_.schema)
                except jsonschema.ValidationError as error:
                    raise TypeError(
                        "Implementation returned invalid value") from error
            return return_

    def _build_lambda_payload(self, function, *args, **kwargs):
        arguments_schema = {"type": "object", "properties": {}}
        for argument in function.arguments:
            arguments_schema["properties"][argument.name] = argument.schema
        arguments = function.signature.bind(*args, **kwargs)
        arguments_dict = {}
        for argument_key, argument_value in arguments.arguments.items():
            arguments_dict[argument_key] = argument_value
        try:
            self._service.validator(arguments_schema).validate(arguments_dict)
        except jsonschema.ValidationError as error:
            raise TypeError("bad arguments") from error
        return arguments_dict

    def send(self, name, message):
        if name not in self._channels:
            raise NotImplementedError(f"no implementation for '{name}'")
        arn = self._channels[name]
        arn_parsed = arnparse.arnparse(arn)
        if arn_parsed.service == "sns":
            session = boto3.Session(region_name=arn_parsed.region)
            sns = session.client("sns")
            sns.publish(
                TopicArn=arn,
                Message=json.dumps(message),
            )
        elif arn_parsed.service == "sqs":
            session = boto3.Session(region_name=arn_parsed.region)
            sqs = session.client("sqs")
            sqs_queue_url = sqs.get_queue_url(
                QueueName=arn_parsed.resource,
                QueueOwnerAWSAccountId=arn_parsed.account_id,
            )["QueueUrl"]
            sqs.send_message(
                QueueUrl=sqs_queue_url,
                MessageBody=json.dumps(message),
            )
        else:
            raise NotImplementedError
